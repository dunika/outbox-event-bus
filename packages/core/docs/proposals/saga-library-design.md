# Proposal: @outbox-event-bus/sagas (Refined)

## 1. Executive Summary

We propose a library implementation of the **Routing Slip Pattern**, heavily inspired by **MassTransit Courier**. 

This directly addresses the complexity of the "Mega-Mart" use case by replacing the "Manual Saga Orchestration" (central database + 5 listeners + reaper) with a **stateless, distributed, message-based workflow**.

**Philosophy**: "State in the Envelope".
Instead of storing the state of the transaction in a database table (`OrderSaga`), we store the state *inside the message itself* (the `RoutingSlip`). This slip travels from queue to queue, carrying its own modification history and future itinerary.

---

## 2. The Core Concept: Activities

In this simplified design, there are no "Sagas" or "State Machines" for linear flows. There are only **Activities**.

An `Activity` is a distinct step that has an **Execute** (Forward) action and a **Compensate** (Backward) action.

```typescript
export interface Activity<TArgs = any, TLog = any> {
  name: string;
  
  // Forward: Do the work
  execute(context: ActivityContext<TArgs>): Promise<executionResult>;
  
  // Backward: Undo the work (if a later step fails)
  compensate(context: CompensateContext<TLog>): Promise<CompensationResult>;
}
```

### 2.1 The "Mega-Mart" Activities

| Activity | Execute Arguments | Compensate Log (State needed to undo) |
| :--- | :--- | :--- |
| **ReserveInventory** | `{ items: [] }` | `{ reservationId: 'abc' }` |
| **CheckFraud** | `{ amount: 100 }` | `null` (Read-only, no undo needed) |
| **ProcessPayment** | `{ amount: 100 }` | `{ transactionId: 'txn_123' }` |
| **ShipOrder** | `{ address: '...' }` | `{ shipmentId: 'shp_789' }` |

---

## 3. The Implementation (Simpler & Robust)

We eliminate the `SagaState` database table entirely. The "Orchestrator" is just a transient builder that sends the first message.

### 3.1 The Builder

// Create the slip
const builder = new RoutingSlipBuilder(orderId);
builder.expiresIn(30, 'minutes'); // [Refinement] Passive Timeout

// Add steps (The Itinerary)
// The builder verifies we have the necessary input arguments for each step
builder.addActivity('ReserveInventory', { items: cart.items });
builder.addActivity('CheckFraud', { customerId: user.id });

// [Refinement] Dynamic Arguments: 
// Sometimes 'ProcessPayment' needs data generated by a previous step (not known at build time).
// We rely on the Activity merging data into the shared 'variables' bag.
builder.addActivity('ProcessPayment', { amount: cart.total }); 
builder.addActivity('ShipOrder', { address: user.address });

// GO -> Emits 'RoutingSlipCreated' and sends the first command to 'ReserveInventory' queue
await bus.execute(builder.build());
```

### 3.1.b Dynamic Data (The Missing Link)

To handle cases where Step B needs an ID generated by Step A:

1.  **Step A (`Execute`)** returns new variables:
    ```typescript
    return Result.Next({ 
      vars: { paymentTransactionId: 'txn_123' } 
    });
    ```
2.  **The Engine** merges these into the Slip's `variables`.
3.  **Step B** access them via `context.variables.paymentTransactionId`.

### 3.2 The Envelope (The State)

The `RoutingSlip` message contains:

1.  **Itinerary**: Stack of steps *remaining* (e.g., `[ProcessPayment, ShipOrder]`).
2.  **ActivityLog**: Stack of steps *completed* (e.g., `[ReserveInventory, CheckFraud]`).
3.  **Variables**: Shared state bag (read/write).
4.  **Args**: Specific arguments for the *current* step.
5.  **ExpiresAt**: (Optional) Timestamp when the workflow should be considered "Timed Out".

### 3.3 The Engine (Robustness)

A generic `RoutingSlipExecutor` listens on the queues. 

**Scenario: Happy Path**
1.  **ReserveInventory** receives Slip.
2.  **Timeout Check**: Checks `if (Date.now() > slip.expiresAt)`.
    *   If expired, throws `RoutingSlipTimeoutError`.
    *   This triggers **Compensation Mode** immediately.
3.  Runs `execute()`. Success! Returns `Result.Next()`.
3.  Engine moves `ReserveInventory` from **Itinerary** -> **ActivityLog**.
4.  Engine looks at **Itinerary**, sees **CheckFraud**.
5.  Engine sends the modified Slip to the **CheckFraud** queue.

**Scenario: Failure & Compensation**
1.  **ShipOrder** fails (e.g., Invalid Address).
2.  Runs `execute()`. Fails! Throws Error.
3.  Engine catches error.
4.  **Automatic Robustness**:
    *   **RetryPolicy**: If defined (e.g., `retry: { count: 3 }`), it schedules a redelivery of the slip.
    *   If retries exhausted, it switches the Slip to **Compensation Mode**.
5.  **Compensation Mode**:
    *   Engine looks at **ActivityLog**. Pops the last item: **ProcessPayment**.
    *   Sends Slip to **ProcessPayment** queue with mode `COMPENSATE`.
    *   **ProcessPayment** runs `compensate({ transactionId: 'txn_123' })`.
    *   Success. Pops next: **CheckFraud** (No-op).
    *   Pops next: **ReserveInventory**. Runs `compensate()`.
    *   Log empty. Emits `RoutingSlipFaulted` (Final Failure).

---

## 4. Why This is "As Good As It Gets"

### 4.1 Simplicity
*   **Zero DB Writes**: No more `tx.saga.create`, `tx.saga.update`. We use the Outbox Pattern (which we already have) to ensure the Message *is* the record of truth.
*   **Decoupled**: `ProcessPayment` doesn't know it comes after `CheckFraud`. It just knows how to pay and refund.
*   **No Reaper**: We rely on the Message Queue's existing "Dead Letter" or "Retry" mechanisms. A "stuck" saga is just a message waiting to be processed.

### 4.2 Robustness
*   **Atomic State**: Since the state travels with the message, we never have "Split Brain" (DB says one thing, Event Bus says another).
*   **Observability**: We emit standard events for every state change.
    *   `RoutingSlipActivityCompleted` { name: 'ReserveInventory', duration: 15ms }
    *   `RoutingSlipActivityFaulted` { name: 'ShipOrder', error: 'Invalid Address' }
*   **Idempotency**: The implementation handles duplicate messages by checking if the activity is ultimately already in the Log vs Itinerary.

## 5. Handling "Mega-Mart" Requirements

| Requirement | Manual Saga Solution | Routing Slip Solution |
| :--- | :--- | :--- |
| **Linear Flow** | Hardcoded Event Listeners | `RoutingSlipBuilder` |
| **Data Sharing** | DB Lookups / Payload passing | Slip `variables` |
| **Compensation** | Manual `compensationStack` in DB | Auto-managed `ActivityLog` in Slip |
| **Timeouts** | Custom "Reaper" Cron Job | Passive Check (`expiresAt`) |
| **Divergent Logic** | `if/else` in handlers | Two different Routing Slips (one for digital, one for physical) |

## 6. Conclusion

For the "Mega-Mart" example and workflows like it (Distributed Transactions), the **Routing Slip** is superior. It is simpler (less code, no DB schema) and safer (state relies on the fundamental transport guarantee).

We will keep **State Machines** in the back pocket for *non-linear* workflows (e.g., long-running customer lifecycle management), but for "Processing an Order", Routing Slips are the best choice.
